<!-- title: STR | Scheduling Algorithms -->

# Real Time Systems: Scheduling Algorithms <!-- omit from toc -->

## Index <!-- omit from toc -->

- [Introduction](#introduction)
- [Concepts](#concepts)
  - [Hyperperiod](#hyperperiod)
  - [Secondary Period](#secondary-period)
    - [Secondary Period: First Condition](#secondary-period-first-condition)
    - [Secondary Period: Second Condition](#secondary-period-second-condition)
    - [Secondary Period: Third Condition](#secondary-period-third-condition)
  - [Response Time Analysis](#response-time-analysis)
  - [Critical Time](#critical-time)
  - [Absolute Deadline](#absolute-deadline)
  - [Contribution](#contribution)
  - [Processor on Demand Criterion](#processor-on-demand-criterion)
  - [Arrival Time](#arrival-time)
  - [Aperiodic tasks](#aperiodic-tasks)
- [Cyclic Scheduler](#cyclic-scheduler)
  - [Cyclic Scheduler: Requisites](#cyclic-scheduler-requisites)
  - [Cyclic Scheduler: Methodology](#cyclic-scheduler-methodology)
  - [Cyclic Scheduler: Pros](#cyclic-scheduler-pros)
  - [Cyclic Scheduler: Cons](#cyclic-scheduler-cons)
- [Rate Monotonic](#rate-monotonic)
  - [Rate Monotonic: Requisites](#rate-monotonic-requisites)
  - [Rate Monotonic: Methodology](#rate-monotonic-methodology)
    - [Rate Monotonic: Methodology \> Condition 1](#rate-monotonic-methodology--condition-1)
    - [Rate Monotonic: Methodology \> Condition 2](#rate-monotonic-methodology--condition-2)
    - [Rate Monotonic: Pros](#rate-monotonic-pros)
    - [Rate Monotonic: Cons](#rate-monotonic-cons)
- [Deadline Monotonic](#deadline-monotonic)
  - [Deadline Monotonic: Requisites](#deadline-monotonic-requisites)
  - [Deadline Monotonic: Methodology](#deadline-monotonic-methodology)
  - [Deadline Monotonic: Pros](#deadline-monotonic-pros)
  - [Deadline Monotonic: Cons](#deadline-monotonic-cons)
- [Earliest Deadline First](#earliest-deadline-first)
  - [Earliest Deadline First: Requisites](#earliest-deadline-first-requisites)
  - [Earliest Deadline First: Methodology](#earliest-deadline-first-methodology)
    - [Earliest Deadline First: Methodology \> Processor on Demand Criterion](#earliest-deadline-first-methodology--processor-on-demand-criterion)
  - [Earliest Deadline First: Precedence](#earliest-deadline-first-precedence)
  - [Earliest Deadline First: New Task](#earliest-deadline-first-new-task)
  - [Earliest Deadline First: Pros](#earliest-deadline-first-pros)
  - [Earliest Deadline First: Cons](#earliest-deadline-first-cons)

## Introduction

Various basic scheduling algorithms. For these to work, we need more information about the task other than it's [basics](./T1.md#notation-tasks). Now each task also has a priority $P$.

## Concepts

New concepts

### Hyperperiod

A hyperperiod $H$ is period where the set of tasks will go back to the base line. It is computed as the _least common factor_ of all [periods](./T1.md#period). Formally written:

$$
H = \underset{1 \le i \le n}{\text{lcm}} T_{i}
$$

### Secondary Period

A secondary period where it is fitted between the longest computing time, shortest deadline. It has 2 other conditions. Formally defined:

$$
\begin{cases}
    & T_s \in \lbrack \underset{1 \le i \le n}{\text{min}} D_{i}, \underset{1 \le i \le n}{\text{max}} C_{i} \rbrack
    \\
    & H = kT_{s}, k \in \Z^{+}
    \\
    & \forall i: 2T_{s} - \text{gcd}(T_{s}, T_{i}) \le D_{i}
\end{cases}
$$

#### Secondary Period: First Condition

The first condition of the secondary period is:

$$
T_s \in \lbrack \underset{1 \le i \le n}{\text{min}} D_{i}, \underset{1 \le i \le n}{\text{max}} C_{i} \rbrack
$$

Basically it states that T_{s} must be _grater than or equal_ to the _maximum compute time_ of all tasks. It also needs to be _less than or equal_ the _shortest deadline_ of all tasks.

#### Secondary Period: Second Condition

This condition is defined as:

$$
H = kT_{s}, k \in \Z^{+}
$$

This condition states that $T_{s}$ is proportional to the hyperperiod $H$ with a factor of $k$, with $k$ being a positive complex ($\Z^{+}$) value.

#### Secondary Period: Third Condition

This condition is defined as:

$$
\forall i: 2T_{s} - \text{gcd}(T_{s}, T_{i}) \le D_{i}
$$

It basically means that for all tasks, the operation:

$$
2T_{s} - \text{gcd}(T_{s}, T_{i})
$$

Must be _less than or equal_ to the deadline of the each task. This condition might fail and you can try _task splitting_. This technique consists on splitting a single task into different parts, always without the _critical section_ in the edge of a section.

$$
\begin{align*}
    & T_{a}\;\text{is split into 2 parts}:
    \\
    & \qquad \begin{cases}
        T_{a1} &= T_{a}
        \\
        T_{a2} &= T_{a}
    \end{cases}
    \\
    & \qquad \begin{cases}
        D_{a1} &= D_{a}
        \\
        D_{a2} &= D_{a}
    \end{cases}
    \\
    & \qquad \begin{cases}
        C_{a1} &= C_{a}
        \\
        C_{a2} &= C_{a}
    \end{cases}
\end{align*}
$$

<p class="page-break" />

### Response Time Analysis

This analysis checks the interference due to [preemption](./T2.md#preemption) of a higher priority task. Note that this only applies if $D_{i} \le T_{i}$.

The response time $R_{i}$ is based on the computing time $c_{i}$ and the interference $I_{i}$ produced by a higher priority task, preempting this lower priority one. It is defined as:

$$
\begin{align*}
    & \forall \tau_{i}: R_{i} = C_{i} + I_{i}
    \\
    & I_{i} = \sum_{j \in hp(i)} \lceil {\tfrac{R_{i}}{T_{j}}} \rceil C_{j}
    \\
    & hp(i) = \lbrace {j: 1..n | P_{j} > P_{i}} \rbrace
\end{align*}
$$

The function $hp(i)$ start for _higher priority_ and it is a set of tasks that have higher priority than the current one.

The solution basically works using this function:

$$
W_{i}^{n+1} = c_{i} + \sum_{j \in hp(i)} \lceil \tfrac{W_{i}^{n}}{T_{j}} \rceil C_{j}
$$

With $W_{i}^{0} = c_{i}$, corresponding to the response time of task $i$ which cannot be preempted by any other task. Usually this is the task number $1$.

It recursively computes the value $W$ until reaching $W_{i}^{n+1} = W_{i}^{n}$, which implies the solution is in a _steady-state_ and the response time of task $i$ is $R_{i}=W_{i}^{n}$.

It can also finish when the [release time](./T1.md#release-time) is greater than the [deadline](./T1.md#deadline) for any task.

### Critical Time

_Critical time_ refers to instants where a lower priority task is activated at the same time as a higher priority one.

### Absolute [Deadline](./T1.md#deadline)

An _absolute [deadline](./T1.md#deadline)_ is defined as:

$$
d_{i} = \phi_{i} + kT_{i} + D_{i}
$$

The value $\phi_{i}$ refers to the initial phase.

### Contribution

The contribution of a task refers to how much time is uses of an interval. It is denoted as $\eta_{i}(t_{a},t_{b})$.

<p class="page-break" />

### Processor on Demand Criterion

It checks that at any interval, the required computation by a task set is not greater than the available time. Using [response time](#response-time-analysis) $r$ and [absolute deadline](#absolute-deadline) $d$, it is defined as:

$$
g(t_{1}, t_{2}) = \sum_{\substack{r_{i,k} \ge t_1\\d_{i,k} \le t_{2}}} C_{i}
$$

A set of tasks are schedulable if in any time interval the processor demand does not exceed the available time.
$$
\forall t_{1}, t_{2}: g(t_{1}, t_{2}) \le t_{1} - t_{2}
$$

To test this, it is required to find the instances were the task is contributing between $t_{1}$ and $t_{2}$. Also taking into account the [contribution](#contribution):

$$
g(t_{1}, t_{2}) = \sum_{i=1}^{n} \eta_{i}(t_{1}, t_{2}) C_{i} = \sum_{i=1}^{n}\text{max}(0, \lfloor \frac{t_{2} + T_{i} - D_{i}}{T_{i}} \rfloor - \lceil \frac{t_{1}}{T_{i}} \rceil) C_{i}
$$

Given that:

$$
\begin{cases}
    \forall i &: \phi_{i} = 0
    \\
    t_{1} &= 0
    \\
    t_{2} &= L
\end{cases}
$$

Schedulability is **ensured** if $g(0, L) \le L$. The formula simplifies to:

$$
g(0, L) = \sum_{i=1}^{n}\eta_{i}(0,L)C_{i} = \sum_{i=1}^{n}\lfloor \frac{L + T_{i} - D_{i}}{T_{i}} \rfloor C_{i}
$$

If $D_{i} = T_{i}$ then it is simplified to:

$$
g(0, L) = \sum_{i=1}^{n} \lfloor \frac{L}{T_{i}} \rfloor C_{i}
$$

### Arrival Time

Tasks might _arrive_ at a different time than when it's period starts. It is ensured that it's arrival time is fitted:

$$
a_{i} + c_{i} \le d_{i}
$$

### Aperiodic tasks

An _aperiodic task_ is a task that has an [arrival time](#arrival-time) other than 0.

## Cyclic Scheduler

A cyclic scheduler is one where the scheduler chooses which task will be executed. This scheduling is composed of 2 elements:

- **Algorithm**: It determines how the tasks are executed
- **Analysis**: It guarantees timing constraints

In these systems, the time constraints are ensured by design. It needs a **time mechanism** that triggers the scheduler periodically.

### Cyclic Scheduler: Requisites

The baseline of these systems are defined as:

- 1 processor.
- Static tasks.
- Periodic tasks.
- No _precedence_ among tasks.
- The [WCET](./T2.md#worst-case-execution-time) is know for all tasks. They are all less of equal to their [deadline](./T1.md#deadline).
- [Deadlines](./T1.md#deadline) of each task are _equal_ to their [period](./T1.md#period).

### Cyclic Scheduler: Methodology

For a _cyclic scheduler_ to be schedulable it needs to meet 2 criteria:

- The [utilization factor](./T2.md#utilization-factor) must be _less or equal_ than $1$
- Using the [hyperperiod](#hyperperiod) find the [secondary period](#secondary-period) that satisfies all of it's conditions.

### Cyclic Scheduler: Pros

- It is **static**, simple, easy to handle and robust
- [Deadlines](./T1.md#deadline) are ensured by design
- No concurrency nor [preemption](./T2.md#preemption)
- No mutual exclusion
- Low-Level scheduler

### Cyclic Scheduler: Cons

- Not flexible
- Segmentation of tasks increases the complexity
- Not adequate for _sporadic tasks_
- Hard to find task allocation within few frames
- Low-Level scheduler

## Rate Monotonic

Since each task has different rates ([periods](./T1.md#period)) we can order them by that criteria. High frequency tasks have higher priorities. Formally written:

$$
\forall{\tau_{i},\;\tau_{j}}: \; T_{i} \lt T_{j} \; \Rightarrow P_{i} \gt P_{j}
\\
P_{i} \propto \frac{1}{T_{i}}
$$

This means that the priorities are proportional to the inverse of the [period](./T1.md#period). The system will run the task with highest priority on each tick. This implies that [preemption](./T2.md#preemption) is possible.

Other important properties:

- The schedulability analysis attempts to know in advance the if all [release times](./T1.md#release-time) occurs before its [deadline](./T1.md#deadline)- The analysis is only performed at the [_critical time_](#critical-time).
- At runtime, the scheduler checks at each tick, the task with highest priority and dispatches it.

### Rate Monotonic: Requisites

These systems have the same [base requisites](#cyclic-scheduler-requisites) as a [cyclic scheduler](#cyclic-scheduler). It adds 2 new requirements:

- 1 processor.
- Static tasks.
- Periodic tasks.
- No _precedence_ among tasks.
- The [WCET](./T2.md#worst-case-execution-time) is know for all tasks. They are all less of equal to their [deadline](./T1.md#deadline).
- [Deadlines](./T1.md#deadline) of each task are _equal_ to their [period](./T1.md#period).
- **Tasks can be preempted**
- **Real Time kernels uses _fixed priorities_**

### Rate Monotonic: Methodology

For a rate _monotonic scheduler_ to work it needs to fulfill one of 2 _sufficient_ conditions:

- [Factor utilization factor sum](#rate-monotonic-methodology--condition-1)
- [Hyperbolic bound](#rate-monotonic-methodology--condition-2)

If neither of these 2 conditions are satisfied, check [response time analysis](#response-time-analysis) for the critical section.

#### Rate Monotonic: Methodology > Condition 1

This first condition requires the sum of the [utilization factor](./T2.md#utilization-factor) of all tasks needs to be _less than or equal_ to $n(\sqrt[n]{2}-1)$. Formally written:

$$
U_{total} = \sum^{n}_{i=1} U_{i} \le n \lparen \sqrt[n]{2} - 1 \rparen
$$

#### Rate Monotonic: Methodology > Condition 2

This condition checks the following formula:

$$
\prod_{i=1}^{n} \lparen U_{i} + 1 \rparen \le 2
$$

#### Rate Monotonic: Pros

- At design time, priorities are configured based on rate of occurrence of each task
- 2 sufficient conditions
- [Response time analysis](#response-time-analysis) being a necessary and sufficient condition
- Feasibility of scheduler is checked at critical time (less work to do)

#### Rate Monotonic: Cons

- It allows [_preemption_](./T2.md#preemption)
- Depends a lot on CPU utilization.

$$
\lim_{n \rightarrow \infty} U_{\text{total}} = \lim_{n \rightarrow \infty} n(\sqrt[n]{2} - 1) = ln(2) = 0.6931...
$$

## Deadline Monotonic

Deadline monotonic is a variant of [rate monotonic](#rate-monotonic), used for tasks with [deadlines](./T1.md#deadline) _less or equal_ than their [period](./T1.md#period).

$$
\forall{\tau_{i},\;\tau_{j}}: \; D_{i} \lt D_{j} \; \Rightarrow P_{i} \gt P_{j}
\\
P_{i} \propto \frac{1}{D_{i}}
$$

This means that the priorities are proportional to the inverse of the [deadline](./T1.md#deadline). The system will run the task with highest priority on each tick. This implies that [preemption](./T2.md#preemption) is possible.

Other important properties:

- The schedulability analysis attempts to know in advance the if all [release times](./T1.md#release-time) occurs before its [deadline](./T1.md#deadline)
- The analysis is only performed at the [_critical time_](#critical-time).
- At runtime, the scheduler checks at each tick, the task with highest priority and dispatches it.

### Deadline Monotonic: Requisites

- 1 processor.
- Static tasks.
- Periodic tasks.
- No _precedence_ among tasks.
- The [WCET](./T2.md#worst-case-execution-time) is know for all tasks. They are all less of equal to their [deadline](./T1.md#deadline).
- [Deadlines](./T1.md#deadline) of each task **are _less or equal_** to their [period](./T1.md#period).
- **Tasks can be preempted**
- **Real Time kernels uses _fixed priorities_**

### Deadline Monotonic: Methodology

It only applies [response time analysis](#response-time-analysis), not using the 2 other sufficient conditions of [rete monotonic](#rate-monotonic-methodology).

### Deadline Monotonic: Pros

- At design time, priorities are configured based on rate of occurrence of each task
- [Response time analysis](#response-time-analysis) being a necessary and sufficient condition

### Deadline Monotonic: Cons

- Preemption
- Performance depends on system ticks

## Earliest Deadline First

At run time, each system tick will check the priorities of active tasks and priorities are modified if needed.

$$
\forall t, \tau_{i}, \tau_{j}:\;d_{i} \lt d_{j} \Rightarrow P_{i} \gt P_{j}
\\
P_{i} \propto \frac{1}{d_{i}}
$$

Where $d$ is the [absolute deadline](#absolute-deadline). This means that priorities are proportional to the inverse of the [absolute deadline](#absolute-deadline). At each system tick, the scheduler looks for the highest priority tasks among active ones. This implies that [preemption](./T2.md#preemption) is possible.

Other important properties:

- The schedulability analysis attempts to know in advance the if all [release times](./T1.md#release-time) occurs before its [deadline](./T1.md#deadline)

### Earliest Deadline First: Requisites

- 1 processor
- ~~Static tasks~~
- ~~Periodic tasks~~
- ~~No _precedence_ among tasks~~
- The [WCET](./T2.md#worst-case-execution-time) is know for all tasks. They are all less of equal to their [deadline](./T1.md#deadline)
- [Deadlines](./T1.md#deadline) of each task **are _less or equal_** to their [period](./T1.md#period)
- **Periodic or aperiodic tasks**
- **It allows precedence among tasks**
- **Tasks can be preempted**
- **Real Time kernels uses _dynamic priorities_**

### Earliest Deadline First: Methodology

There are 2 cases to check:

1. If $D_{i} = T_{i}$ then the necessary and sufficient condition is $U_{total} \le 1$
2. If $D_{i} \lt T_{i}$ then it is necessary to check [processor on demand criterion](#processor-on-demand-criterion)

#### Earliest Deadline First: Methodology > [Processor on Demand Criterion](#processor-on-demand-criterion)

To check [processor on demand criterion](#processor-on-demand-criterion) it is required to find $L$:

$$
L \ge \sum_{i=1}^{n}(\lfloor \frac{L - D_{i}}{T_{i}} \rfloor + 1) C_{i}
$$

<p class="page-break" />

Using this value, find $g(0,L) \le L$ with the [absolute deadlines](#absolute-deadline) obtained from the following set:

$$
\begin{cases}
    D &= \lbrack d_{k} | d_{k} \le \text{min}(H, L^{*}) \rbrack
    \\
    H &= \text{lcm}(T_{1}, T_{2}, ..., T_{n})
    \\
    L^{*} &= \dfrac{\sum_{i=1}^{n}(T_{i} - D_{i})U_{i}}{1 - U_{total}}
\end{cases}
$$

### Earliest Deadline First: Precedence

One special case of [EDF](#earliest-deadline-first) consists of task having precedence, meaning $\tau_{a} \rightarrow \tau_{b}$. The main effect is that both [arrival time](#arrival-time) and [deadlines](./T1.md#deadline) are modified::

$$
\begin{align*}
    &\tau_{a} \rightarrow \tau_{b}:
    \\
    & \qquad \begin{cases}
        a_{b}^{*} &= a_{a} + C_{a}
        \\
        d_{a}^{*} &= d_{b} + C_{b}
    \end{cases}
    \\
    &\text{Where}\;a\;\text{is the arrival time}
\end{align*}
$$

Given that a set $J$ of tasks can transform into a set $J^{*}$ of tasks, both the [arrival times](#arrival-time) and [deadlines](./T1.md#deadline) must be modified:

$$
\begin{align*}
    &\text{From the set of tasks}\;J\;\text{to}\;J^{*}
    \\
    \\
    &\textbf{Arrival time}:
    \\
    & \left| \begin{align*}
        \quad 1. \; & \text{Select task}\;\tau_{i}\;\text{with a modified immediate predecesor}
        \\
        \quad 2. \; & \text{max}_{\text{arrival}} = \underset{\tau_{k} \rightarrow \tau_{i}}{\text{max}}(a_{k}^{*} + C_{k}), k \in J
        \\
        \quad 3. \; & \text{Set}\;a_{i}^{*}=\text{max} \lbrace a_{i}, \text{max}_{\text{arrival}} \rbrace
    \end{align*}\right.
    \\
    &\textbf{Deadline}:
    \\
    & \left| \begin{align*}
        \quad 1. \; & \text{Select task}\;\tau_{i}\;\text{with a modified immediate successor}
        \\
        \quad 2. \; & \text{min}_{\text{deadline}} = \underset{\tau_{k} \rightarrow \tau_{i}}{\text{min}}(d_{k}^{*} - C_{k}), k \in J
        \\
        \quad 3. \; & \text{Set}\;d_{i}^{*}=\text{min} \lbrace d_{i}, \text{min}_{\text{deadline}} \rbrace
    \end{align*}\right.
\end{align*}
$$

### Earliest Deadline First: New Task

Given that [EDF](#earliest-deadline-first) checks at runtime, you can add tasks to it. This will transform the set of tasks $J$ to $J_{\text{new}}$.

For this to work, the following must be true:

$$
\begin{align*}
    & \text{With}\;J_{\text{new}} \bigcup J = J':
    \\
    & \qquad \text{for all}\;i\;\text{in}\;J': f_{i} \le d_{i}
    \\
    & \qquad \qquad \begin{cases}
        & f_{i} = \sum_{k = 1}^{n} b_{k}
        \\
        & b_{k}:\;\text{remaining \textit{Worst Case Execution Time} of a task}\;i\;\text{in}\;J'
    \end{cases}
\end{align*}
$$

Basically check if adding this new task, with the remaining times up to the extra time for not reaching the [deadline](./T1.md#deadline) of each tasks, it will fit.

### Earliest Deadline First: Pros

- Uses _dynamic priorities_ set at runtime
- If $T_{i} = D_{i}$, then $U_{total} \le 1$ is a sufficient condition
- It accepts [aperiodic tasks](#aperiodic-tasks)

### Earliest Deadline First: Cons

- It is less predictable and less controllable, when trying to reduce response time
- It requires more overhead
- Overload can lead to a domino effect
